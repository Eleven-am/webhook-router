// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: postgres.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBrokerConfig = `-- name: CreateBrokerConfig :one
INSERT INTO broker_configs (name, type, config, active, health_status, dlq_enabled, dlq_broker_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, name, type, config, active, health_status, last_health_check, created_at, updated_at, dlq_enabled, dlq_broker_id
`

type CreateBrokerConfigParams struct {
	Name         string  `json:"name"`
	Type         string  `json:"type"`
	Config       []byte  `json:"config"`
	Active       *bool   `json:"active"`
	HealthStatus *string `json:"health_status"`
	DlqEnabled   *bool   `json:"dlq_enabled"`
	DlqBrokerID  *int32  `json:"dlq_broker_id"`
}

// Broker configs queries
func (q *Queries) CreateBrokerConfig(ctx context.Context, arg CreateBrokerConfigParams) (BrokerConfig, error) {
	row := q.db.QueryRow(ctx, createBrokerConfig,
		arg.Name,
		arg.Type,
		arg.Config,
		arg.Active,
		arg.HealthStatus,
		arg.DlqEnabled,
		arg.DlqBrokerID,
	)
	var i BrokerConfig
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.Active,
		&i.HealthStatus,
		&i.LastHealthCheck,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DlqEnabled,
		&i.DlqBrokerID,
	)
	return i, err
}

const createDLQMessage = `-- name: CreateDLQMessage :one
INSERT INTO dlq_messages (
    message_id, route_id, trigger_id, pipeline_id, source_broker_id, dlq_broker_id,
    broker_name, queue, exchange, routing_key, headers, body, error_message,
    failure_count, first_failure, last_failure, next_retry, status, metadata
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
RETURNING id, message_id, route_id, trigger_id, pipeline_id, source_broker_id, dlq_broker_id, broker_name, queue, exchange, routing_key, headers, body, error_message, failure_count, first_failure, last_failure, next_retry, status, metadata, created_at, updated_at
`

type CreateDLQMessageParams struct {
	MessageID      string           `json:"message_id"`
	RouteID        int32            `json:"route_id"`
	TriggerID      *int32           `json:"trigger_id"`
	PipelineID     *int32           `json:"pipeline_id"`
	SourceBrokerID int32            `json:"source_broker_id"`
	DlqBrokerID    int32            `json:"dlq_broker_id"`
	BrokerName     string           `json:"broker_name"`
	Queue          string           `json:"queue"`
	Exchange       *string          `json:"exchange"`
	RoutingKey     string           `json:"routing_key"`
	Headers        []byte           `json:"headers"`
	Body           string           `json:"body"`
	ErrorMessage   string           `json:"error_message"`
	FailureCount   *int32           `json:"failure_count"`
	FirstFailure   pgtype.Timestamp `json:"first_failure"`
	LastFailure    pgtype.Timestamp `json:"last_failure"`
	NextRetry      pgtype.Timestamp `json:"next_retry"`
	Status         *string          `json:"status"`
	Metadata       []byte           `json:"metadata"`
}

// DLQ queries
func (q *Queries) CreateDLQMessage(ctx context.Context, arg CreateDLQMessageParams) (DlqMessage, error) {
	row := q.db.QueryRow(ctx, createDLQMessage,
		arg.MessageID,
		arg.RouteID,
		arg.TriggerID,
		arg.PipelineID,
		arg.SourceBrokerID,
		arg.DlqBrokerID,
		arg.BrokerName,
		arg.Queue,
		arg.Exchange,
		arg.RoutingKey,
		arg.Headers,
		arg.Body,
		arg.ErrorMessage,
		arg.FailureCount,
		arg.FirstFailure,
		arg.LastFailure,
		arg.NextRetry,
		arg.Status,
		arg.Metadata,
	)
	var i DlqMessage
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.RouteID,
		&i.TriggerID,
		&i.PipelineID,
		&i.SourceBrokerID,
		&i.DlqBrokerID,
		&i.BrokerName,
		&i.Queue,
		&i.Exchange,
		&i.RoutingKey,
		&i.Headers,
		&i.Body,
		&i.ErrorMessage,
		&i.FailureCount,
		&i.FirstFailure,
		&i.LastFailure,
		&i.NextRetry,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPipeline = `-- name: CreatePipeline :one
INSERT INTO pipelines (name, description, stages, active)
VALUES ($1, $2, $3, $4)
RETURNING id, name, description, stages, active, created_at, updated_at
`

type CreatePipelineParams struct {
	Name        string  `json:"name"`
	Description *string `json:"description"`
	Stages      []byte  `json:"stages"`
	Active      *bool   `json:"active"`
}

// Pipelines queries
func (q *Queries) CreatePipeline(ctx context.Context, arg CreatePipelineParams) (Pipeline, error) {
	row := q.db.QueryRow(ctx, createPipeline,
		arg.Name,
		arg.Description,
		arg.Stages,
		arg.Active,
	)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Stages,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRoute = `-- name: CreateRoute :one
INSERT INTO routes (
    name, endpoint, method, queue, exchange, routing_key,
    filters, headers, active, pipeline_id, trigger_id,
    destination_broker_id, priority, condition_expression,
    signature_config, signature_secret
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
RETURNING id, name, endpoint, method, queue, exchange, routing_key, filters, headers, active, created_at, updated_at, pipeline_id, trigger_id, destination_broker_id, priority, condition_expression, signature_config, signature_secret
`

type CreateRouteParams struct {
	Name                string  `json:"name"`
	Endpoint            string  `json:"endpoint"`
	Method              string  `json:"method"`
	Queue               string  `json:"queue"`
	Exchange            *string `json:"exchange"`
	RoutingKey          string  `json:"routing_key"`
	Filters             []byte  `json:"filters"`
	Headers             []byte  `json:"headers"`
	Active              *bool   `json:"active"`
	PipelineID          *int32  `json:"pipeline_id"`
	TriggerID           *int32  `json:"trigger_id"`
	DestinationBrokerID *int32  `json:"destination_broker_id"`
	Priority            *int32  `json:"priority"`
	ConditionExpression *string `json:"condition_expression"`
	SignatureConfig     []byte  `json:"signature_config"`
	SignatureSecret     *string `json:"signature_secret"`
}

// Routes queries
func (q *Queries) CreateRoute(ctx context.Context, arg CreateRouteParams) (Route, error) {
	row := q.db.QueryRow(ctx, createRoute,
		arg.Name,
		arg.Endpoint,
		arg.Method,
		arg.Queue,
		arg.Exchange,
		arg.RoutingKey,
		arg.Filters,
		arg.Headers,
		arg.Active,
		arg.PipelineID,
		arg.TriggerID,
		arg.DestinationBrokerID,
		arg.Priority,
		arg.ConditionExpression,
		arg.SignatureConfig,
		arg.SignatureSecret,
	)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Endpoint,
		&i.Method,
		&i.Queue,
		&i.Exchange,
		&i.RoutingKey,
		&i.Filters,
		&i.Headers,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PipelineID,
		&i.TriggerID,
		&i.DestinationBrokerID,
		&i.Priority,
		&i.ConditionExpression,
		&i.SignatureConfig,
		&i.SignatureSecret,
	)
	return i, err
}

const createTrigger = `-- name: CreateTrigger :one
INSERT INTO triggers (name, type, config, status, active)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, type, config, status, active, error_message, last_execution, next_execution, created_at, updated_at
`

type CreateTriggerParams struct {
	Name   string  `json:"name"`
	Type   string  `json:"type"`
	Config []byte  `json:"config"`
	Status *string `json:"status"`
	Active *bool   `json:"active"`
}

// Triggers queries
func (q *Queries) CreateTrigger(ctx context.Context, arg CreateTriggerParams) (Trigger, error) {
	row := q.db.QueryRow(ctx, createTrigger,
		arg.Name,
		arg.Type,
		arg.Config,
		arg.Status,
		arg.Active,
	)
	var i Trigger
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.Status,
		&i.Active,
		&i.ErrorMessage,
		&i.LastExecution,
		&i.NextExecution,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (username, password_hash, is_default)
VALUES ($1, $2, $3)
RETURNING id, username, password_hash, is_default, created_at, updated_at
`

type CreateUserParams struct {
	Username     string `json:"username"`
	PasswordHash string `json:"password_hash"`
	IsDefault    *bool  `json:"is_default"`
}

// PostgreSQL-specific queries using $1, $2 syntax
// Users queries
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Username, arg.PasswordHash, arg.IsDefault)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWebhookLog = `-- name: CreateWebhookLog :one
INSERT INTO webhook_logs (
    route_id, method, endpoint, headers, body, status_code,
    error, trigger_id, pipeline_id, transformation_time_ms,
    broker_publish_time_ms
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, route_id, method, endpoint, headers, body, status_code, error, processed_at, trigger_id, pipeline_id, transformation_time_ms, broker_publish_time_ms
`

type CreateWebhookLogParams struct {
	RouteID              *int32  `json:"route_id"`
	Method               string  `json:"method"`
	Endpoint             string  `json:"endpoint"`
	Headers              []byte  `json:"headers"`
	Body                 *string `json:"body"`
	StatusCode           *int32  `json:"status_code"`
	Error                *string `json:"error"`
	TriggerID            *int32  `json:"trigger_id"`
	PipelineID           *int32  `json:"pipeline_id"`
	TransformationTimeMs *int32  `json:"transformation_time_ms"`
	BrokerPublishTimeMs  *int32  `json:"broker_publish_time_ms"`
}

// Webhook logs queries
func (q *Queries) CreateWebhookLog(ctx context.Context, arg CreateWebhookLogParams) (WebhookLog, error) {
	row := q.db.QueryRow(ctx, createWebhookLog,
		arg.RouteID,
		arg.Method,
		arg.Endpoint,
		arg.Headers,
		arg.Body,
		arg.StatusCode,
		arg.Error,
		arg.TriggerID,
		arg.PipelineID,
		arg.TransformationTimeMs,
		arg.BrokerPublishTimeMs,
	)
	var i WebhookLog
	err := row.Scan(
		&i.ID,
		&i.RouteID,
		&i.Method,
		&i.Endpoint,
		&i.Headers,
		&i.Body,
		&i.StatusCode,
		&i.Error,
		&i.ProcessedAt,
		&i.TriggerID,
		&i.PipelineID,
		&i.TransformationTimeMs,
		&i.BrokerPublishTimeMs,
	)
	return i, err
}

const deleteBrokerConfig = `-- name: DeleteBrokerConfig :exec
DELETE FROM broker_configs WHERE id = $1
`

func (q *Queries) DeleteBrokerConfig(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteBrokerConfig, id)
	return err
}

const deleteDLQMessage = `-- name: DeleteDLQMessage :exec
DELETE FROM dlq_messages WHERE id = $1
`

func (q *Queries) DeleteDLQMessage(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteDLQMessage, id)
	return err
}

const deleteOldDLQMessages = `-- name: DeleteOldDLQMessages :exec
DELETE FROM dlq_messages 
WHERE status = 'abandoned' AND first_failure < $1
`

func (q *Queries) DeleteOldDLQMessages(ctx context.Context, firstFailure pgtype.Timestamp) error {
	_, err := q.db.Exec(ctx, deleteOldDLQMessages, firstFailure)
	return err
}

const deleteOldWebhookLogs = `-- name: DeleteOldWebhookLogs :exec
DELETE FROM webhook_logs WHERE processed_at < $1
`

func (q *Queries) DeleteOldWebhookLogs(ctx context.Context, processedAt pgtype.Timestamp) error {
	_, err := q.db.Exec(ctx, deleteOldWebhookLogs, processedAt)
	return err
}

const deletePipeline = `-- name: DeletePipeline :exec
DELETE FROM pipelines WHERE id = $1
`

func (q *Queries) DeletePipeline(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deletePipeline, id)
	return err
}

const deleteRoute = `-- name: DeleteRoute :exec
DELETE FROM routes WHERE id = $1
`

func (q *Queries) DeleteRoute(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteRoute, id)
	return err
}

const deleteSetting = `-- name: DeleteSetting :exec
DELETE FROM settings WHERE key = $1
`

func (q *Queries) DeleteSetting(ctx context.Context, key string) error {
	_, err := q.db.Exec(ctx, deleteSetting, key)
	return err
}

const deleteTrigger = `-- name: DeleteTrigger :exec
DELETE FROM triggers WHERE id = $1
`

func (q *Queries) DeleteTrigger(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteTrigger, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getBrokerConfig = `-- name: GetBrokerConfig :one
SELECT id, name, type, config, active, health_status, last_health_check, created_at, updated_at, dlq_enabled, dlq_broker_id FROM broker_configs WHERE id = $1
`

func (q *Queries) GetBrokerConfig(ctx context.Context, id int32) (BrokerConfig, error) {
	row := q.db.QueryRow(ctx, getBrokerConfig, id)
	var i BrokerConfig
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.Active,
		&i.HealthStatus,
		&i.LastHealthCheck,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DlqEnabled,
		&i.DlqBrokerID,
	)
	return i, err
}

const getBrokerConfigWithDLQ = `-- name: GetBrokerConfigWithDLQ :one
SELECT 
    bc.id, bc.name, bc.type, bc.config, bc.active, bc.health_status, bc.last_health_check, bc.created_at, bc.updated_at, bc.dlq_enabled, bc.dlq_broker_id,
    dlq.id as dlq_id,
    dlq.name as dlq_name,
    dlq.type as dlq_type,
    dlq.config as dlq_config
FROM broker_configs bc
LEFT JOIN broker_configs dlq ON bc.dlq_broker_id = dlq.id
WHERE bc.id = $1
`

type GetBrokerConfigWithDLQRow struct {
	ID              int32            `json:"id"`
	Name            string           `json:"name"`
	Type            string           `json:"type"`
	Config          []byte           `json:"config"`
	Active          *bool            `json:"active"`
	HealthStatus    *string          `json:"health_status"`
	LastHealthCheck pgtype.Timestamp `json:"last_health_check"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
	DlqEnabled      *bool            `json:"dlq_enabled"`
	DlqBrokerID     *int32           `json:"dlq_broker_id"`
	DlqID           *int32           `json:"dlq_id"`
	DlqName         *string          `json:"dlq_name"`
	DlqType         *string          `json:"dlq_type"`
	DlqConfig       []byte           `json:"dlq_config"`
}

func (q *Queries) GetBrokerConfigWithDLQ(ctx context.Context, id int32) (GetBrokerConfigWithDLQRow, error) {
	row := q.db.QueryRow(ctx, getBrokerConfigWithDLQ, id)
	var i GetBrokerConfigWithDLQRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.Active,
		&i.HealthStatus,
		&i.LastHealthCheck,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DlqEnabled,
		&i.DlqBrokerID,
		&i.DlqID,
		&i.DlqName,
		&i.DlqType,
		&i.DlqConfig,
	)
	return i, err
}

const getDLQMessage = `-- name: GetDLQMessage :one
SELECT id, message_id, route_id, trigger_id, pipeline_id, source_broker_id, dlq_broker_id, broker_name, queue, exchange, routing_key, headers, body, error_message, failure_count, first_failure, last_failure, next_retry, status, metadata, created_at, updated_at FROM dlq_messages WHERE id = $1
`

func (q *Queries) GetDLQMessage(ctx context.Context, id int32) (DlqMessage, error) {
	row := q.db.QueryRow(ctx, getDLQMessage, id)
	var i DlqMessage
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.RouteID,
		&i.TriggerID,
		&i.PipelineID,
		&i.SourceBrokerID,
		&i.DlqBrokerID,
		&i.BrokerName,
		&i.Queue,
		&i.Exchange,
		&i.RoutingKey,
		&i.Headers,
		&i.Body,
		&i.ErrorMessage,
		&i.FailureCount,
		&i.FirstFailure,
		&i.LastFailure,
		&i.NextRetry,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDLQMessageByMessageID = `-- name: GetDLQMessageByMessageID :one
SELECT id, message_id, route_id, trigger_id, pipeline_id, source_broker_id, dlq_broker_id, broker_name, queue, exchange, routing_key, headers, body, error_message, failure_count, first_failure, last_failure, next_retry, status, metadata, created_at, updated_at FROM dlq_messages WHERE message_id = $1
`

func (q *Queries) GetDLQMessageByMessageID(ctx context.Context, messageID string) (DlqMessage, error) {
	row := q.db.QueryRow(ctx, getDLQMessageByMessageID, messageID)
	var i DlqMessage
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.RouteID,
		&i.TriggerID,
		&i.PipelineID,
		&i.SourceBrokerID,
		&i.DlqBrokerID,
		&i.BrokerName,
		&i.Queue,
		&i.Exchange,
		&i.RoutingKey,
		&i.Headers,
		&i.Body,
		&i.ErrorMessage,
		&i.FailureCount,
		&i.FirstFailure,
		&i.LastFailure,
		&i.NextRetry,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDLQStatsByDLQBroker = `-- name: GetDLQStatsByDLQBroker :many
SELECT 
    dlq_broker_id,
    COUNT(*) as message_count,
    COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_count,
    COUNT(CASE WHEN status = 'abandoned' THEN 1 END) as abandoned_count
FROM dlq_messages
GROUP BY dlq_broker_id
ORDER BY message_count DESC
`

type GetDLQStatsByDLQBrokerRow struct {
	DlqBrokerID    int32 `json:"dlq_broker_id"`
	MessageCount   int64 `json:"message_count"`
	PendingCount   int64 `json:"pending_count"`
	AbandonedCount int64 `json:"abandoned_count"`
}

func (q *Queries) GetDLQStatsByDLQBroker(ctx context.Context) ([]GetDLQStatsByDLQBrokerRow, error) {
	rows, err := q.db.Query(ctx, getDLQStatsByDLQBroker)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDLQStatsByDLQBrokerRow{}
	for rows.Next() {
		var i GetDLQStatsByDLQBrokerRow
		if err := rows.Scan(
			&i.DlqBrokerID,
			&i.MessageCount,
			&i.PendingCount,
			&i.AbandonedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDLQStatsBySourceBroker = `-- name: GetDLQStatsBySourceBroker :many
SELECT 
    source_broker_id,
    COUNT(*) as message_count,
    COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_count,
    COUNT(CASE WHEN status = 'abandoned' THEN 1 END) as abandoned_count
FROM dlq_messages
GROUP BY source_broker_id
ORDER BY message_count DESC
`

type GetDLQStatsBySourceBrokerRow struct {
	SourceBrokerID int32 `json:"source_broker_id"`
	MessageCount   int64 `json:"message_count"`
	PendingCount   int64 `json:"pending_count"`
	AbandonedCount int64 `json:"abandoned_count"`
}

func (q *Queries) GetDLQStatsBySourceBroker(ctx context.Context) ([]GetDLQStatsBySourceBrokerRow, error) {
	rows, err := q.db.Query(ctx, getDLQStatsBySourceBroker)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDLQStatsBySourceBrokerRow{}
	for rows.Next() {
		var i GetDLQStatsBySourceBrokerRow
		if err := rows.Scan(
			&i.SourceBrokerID,
			&i.MessageCount,
			&i.PendingCount,
			&i.AbandonedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPipeline = `-- name: GetPipeline :one
SELECT id, name, description, stages, active, created_at, updated_at FROM pipelines WHERE id = $1
`

func (q *Queries) GetPipeline(ctx context.Context, id int32) (Pipeline, error) {
	row := q.db.QueryRow(ctx, getPipeline, id)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Stages,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRoute = `-- name: GetRoute :one
SELECT id, name, endpoint, method, queue, exchange, routing_key, filters, headers, active, created_at, updated_at, pipeline_id, trigger_id, destination_broker_id, priority, condition_expression FROM routes WHERE id = $1
`

func (q *Queries) GetRoute(ctx context.Context, id int32) (Route, error) {
	row := q.db.QueryRow(ctx, getRoute, id)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Endpoint,
		&i.Method,
		&i.Queue,
		&i.Exchange,
		&i.RoutingKey,
		&i.Filters,
		&i.Headers,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PipelineID,
		&i.TriggerID,
		&i.DestinationBrokerID,
		&i.Priority,
		&i.ConditionExpression,
	)
	return i, err
}

const getRouteByEndpoint = `-- name: GetRouteByEndpoint :one
SELECT id, name, endpoint, method, queue, exchange, routing_key, filters, headers, active, created_at, updated_at, pipeline_id, trigger_id, destination_broker_id, priority, condition_expression FROM routes WHERE endpoint = $1 AND method = $2
`

type GetRouteByEndpointParams struct {
	Endpoint string `json:"endpoint"`
	Method   string `json:"method"`
}

func (q *Queries) GetRouteByEndpoint(ctx context.Context, arg GetRouteByEndpointParams) (Route, error) {
	row := q.db.QueryRow(ctx, getRouteByEndpoint, arg.Endpoint, arg.Method)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Endpoint,
		&i.Method,
		&i.Queue,
		&i.Exchange,
		&i.RoutingKey,
		&i.Filters,
		&i.Headers,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PipelineID,
		&i.TriggerID,
		&i.DestinationBrokerID,
		&i.Priority,
		&i.ConditionExpression,
	)
	return i, err
}

const getRouteByName = `-- name: GetRouteByName :one
SELECT id, name, endpoint, method, queue, exchange, routing_key, filters, headers, active, created_at, updated_at, pipeline_id, trigger_id, destination_broker_id, priority, condition_expression FROM routes WHERE name = $1
`

func (q *Queries) GetRouteByName(ctx context.Context, name string) (Route, error) {
	row := q.db.QueryRow(ctx, getRouteByName, name)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Endpoint,
		&i.Method,
		&i.Queue,
		&i.Exchange,
		&i.RoutingKey,
		&i.Filters,
		&i.Headers,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PipelineID,
		&i.TriggerID,
		&i.DestinationBrokerID,
		&i.Priority,
		&i.ConditionExpression,
	)
	return i, err
}

const getRouteStatistics = `-- name: GetRouteStatistics :one
SELECT 
    r.id,
    r.name,
    COUNT(w.id) as total_requests,
    COUNT(CASE WHEN w.status_code >= 200 AND w.status_code < 300 THEN 1 END) as successful_requests,
    COUNT(CASE WHEN w.status_code >= 400 THEN 1 END) as failed_requests,
    AVG(w.transformation_time_ms) as avg_transformation_time,
    AVG(w.broker_publish_time_ms) as avg_publish_time,
    MAX(w.processed_at) as last_processed
FROM routes r
LEFT JOIN webhook_logs w ON r.id = w.route_id
WHERE r.id = $1
GROUP BY r.id, r.name
`

type GetRouteStatisticsRow struct {
	ID                    int32       `json:"id"`
	Name                  string      `json:"name"`
	TotalRequests         int64       `json:"total_requests"`
	SuccessfulRequests    int64       `json:"successful_requests"`
	FailedRequests        int64       `json:"failed_requests"`
	AvgTransformationTime float64     `json:"avg_transformation_time"`
	AvgPublishTime        float64     `json:"avg_publish_time"`
	LastProcessed         interface{} `json:"last_processed"`
}

func (q *Queries) GetRouteStatistics(ctx context.Context, id int32) (GetRouteStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getRouteStatistics, id)
	var i GetRouteStatisticsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TotalRequests,
		&i.SuccessfulRequests,
		&i.FailedRequests,
		&i.AvgTransformationTime,
		&i.AvgPublishTime,
		&i.LastProcessed,
	)
	return i, err
}

const getSetting = `-- name: GetSetting :one
SELECT key, value, updated_at FROM settings WHERE key = $1
`

func (q *Queries) GetSetting(ctx context.Context, key string) (Setting, error) {
	row := q.db.QueryRow(ctx, getSetting, key)
	var i Setting
	err := row.Scan(&i.Key, &i.Value, &i.UpdatedAt)
	return i, err
}

const getTrigger = `-- name: GetTrigger :one
SELECT id, name, type, config, status, active, error_message, last_execution, next_execution, created_at, updated_at FROM triggers WHERE id = $1
`

func (q *Queries) GetTrigger(ctx context.Context, id int32) (Trigger, error) {
	row := q.db.QueryRow(ctx, getTrigger, id)
	var i Trigger
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.Status,
		&i.Active,
		&i.ErrorMessage,
		&i.LastExecution,
		&i.NextExecution,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, username, password_hash, is_default, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password_hash, is_default, created_at, updated_at FROM users WHERE username = $1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWebhookLog = `-- name: GetWebhookLog :one
SELECT id, route_id, method, endpoint, headers, body, status_code, error, processed_at, trigger_id, pipeline_id, transformation_time_ms, broker_publish_time_ms FROM webhook_logs WHERE id = $1
`

func (q *Queries) GetWebhookLog(ctx context.Context, id int32) (WebhookLog, error) {
	row := q.db.QueryRow(ctx, getWebhookLog, id)
	var i WebhookLog
	err := row.Scan(
		&i.ID,
		&i.RouteID,
		&i.Method,
		&i.Endpoint,
		&i.Headers,
		&i.Body,
		&i.StatusCode,
		&i.Error,
		&i.ProcessedAt,
		&i.TriggerID,
		&i.PipelineID,
		&i.TransformationTimeMs,
		&i.BrokerPublishTimeMs,
	)
	return i, err
}

const getWebhookLogStats = `-- name: GetWebhookLogStats :one
SELECT 
    COUNT(*) as total_count,
    COUNT(CASE WHEN status_code >= 200 AND status_code < 300 THEN 1 END) as success_count,
    COUNT(CASE WHEN status_code >= 400 THEN 1 END) as error_count,
    AVG(transformation_time_ms) as avg_transformation_time,
    AVG(broker_publish_time_ms) as avg_publish_time,
    MAX(transformation_time_ms) as max_transformation_time,
    MAX(broker_publish_time_ms) as max_publish_time
FROM webhook_logs
WHERE processed_at >= $1
`

type GetWebhookLogStatsRow struct {
	TotalCount            int64       `json:"total_count"`
	SuccessCount          int64       `json:"success_count"`
	ErrorCount            int64       `json:"error_count"`
	AvgTransformationTime float64     `json:"avg_transformation_time"`
	AvgPublishTime        float64     `json:"avg_publish_time"`
	MaxTransformationTime interface{} `json:"max_transformation_time"`
	MaxPublishTime        interface{} `json:"max_publish_time"`
}

func (q *Queries) GetWebhookLogStats(ctx context.Context, processedAt pgtype.Timestamp) (GetWebhookLogStatsRow, error) {
	row := q.db.QueryRow(ctx, getWebhookLogStats, processedAt)
	var i GetWebhookLogStatsRow
	err := row.Scan(
		&i.TotalCount,
		&i.SuccessCount,
		&i.ErrorCount,
		&i.AvgTransformationTime,
		&i.AvgPublishTime,
		&i.MaxTransformationTime,
		&i.MaxPublishTime,
	)
	return i, err
}

const getWebhookLogStatsByRoute = `-- name: GetWebhookLogStatsByRoute :one
SELECT 
    COUNT(*) as total_count,
    COUNT(CASE WHEN status_code >= 200 AND status_code < 300 THEN 1 END) as success_count,
    COUNT(CASE WHEN status_code >= 400 THEN 1 END) as error_count,
    AVG(transformation_time_ms) as avg_transformation_time,
    AVG(broker_publish_time_ms) as avg_publish_time,
    MAX(transformation_time_ms) as max_transformation_time,
    MAX(broker_publish_time_ms) as max_publish_time
FROM webhook_logs
WHERE route_id = $1 AND processed_at >= $2
`

type GetWebhookLogStatsByRouteParams struct {
	RouteID     *int32           `json:"route_id"`
	ProcessedAt pgtype.Timestamp `json:"processed_at"`
}

type GetWebhookLogStatsByRouteRow struct {
	TotalCount            int64       `json:"total_count"`
	SuccessCount          int64       `json:"success_count"`
	ErrorCount            int64       `json:"error_count"`
	AvgTransformationTime float64     `json:"avg_transformation_time"`
	AvgPublishTime        float64     `json:"avg_publish_time"`
	MaxTransformationTime interface{} `json:"max_transformation_time"`
	MaxPublishTime        interface{} `json:"max_publish_time"`
}

func (q *Queries) GetWebhookLogStatsByRoute(ctx context.Context, arg GetWebhookLogStatsByRouteParams) (GetWebhookLogStatsByRouteRow, error) {
	row := q.db.QueryRow(ctx, getWebhookLogStatsByRoute, arg.RouteID, arg.ProcessedAt)
	var i GetWebhookLogStatsByRouteRow
	err := row.Scan(
		&i.TotalCount,
		&i.SuccessCount,
		&i.ErrorCount,
		&i.AvgTransformationTime,
		&i.AvgPublishTime,
		&i.MaxTransformationTime,
		&i.MaxPublishTime,
	)
	return i, err
}

const getWebhookLogsByRouteID = `-- name: GetWebhookLogsByRouteID :many
SELECT id, route_id, method, endpoint, headers, body, status_code, error, processed_at, trigger_id, pipeline_id, transformation_time_ms, broker_publish_time_ms FROM webhook_logs 
WHERE route_id = $1
ORDER BY processed_at DESC 
LIMIT $2 OFFSET $3
`

type GetWebhookLogsByRouteIDParams struct {
	RouteID *int32 `json:"route_id"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) GetWebhookLogsByRouteID(ctx context.Context, arg GetWebhookLogsByRouteIDParams) ([]WebhookLog, error) {
	rows, err := q.db.Query(ctx, getWebhookLogsByRouteID, arg.RouteID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookLog{}
	for rows.Next() {
		var i WebhookLog
		if err := rows.Scan(
			&i.ID,
			&i.RouteID,
			&i.Method,
			&i.Endpoint,
			&i.Headers,
			&i.Body,
			&i.StatusCode,
			&i.Error,
			&i.ProcessedAt,
			&i.TriggerID,
			&i.PipelineID,
			&i.TransformationTimeMs,
			&i.BrokerPublishTimeMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveRoutes = `-- name: ListActiveRoutes :many
SELECT id, name, endpoint, method, queue, exchange, routing_key, filters, headers, active, created_at, updated_at, pipeline_id, trigger_id, destination_broker_id, priority, condition_expression FROM routes WHERE active = true ORDER BY priority ASC, created_at DESC
`

func (q *Queries) ListActiveRoutes(ctx context.Context) ([]Route, error) {
	rows, err := q.db.Query(ctx, listActiveRoutes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Route{}
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Endpoint,
			&i.Method,
			&i.Queue,
			&i.Exchange,
			&i.RoutingKey,
			&i.Filters,
			&i.Headers,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PipelineID,
			&i.TriggerID,
			&i.DestinationBrokerID,
			&i.Priority,
			&i.ConditionExpression,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBrokerConfigs = `-- name: ListBrokerConfigs :many
SELECT id, name, type, config, active, health_status, last_health_check, created_at, updated_at, dlq_enabled, dlq_broker_id FROM broker_configs ORDER BY created_at DESC
`

func (q *Queries) ListBrokerConfigs(ctx context.Context) ([]BrokerConfig, error) {
	rows, err := q.db.Query(ctx, listBrokerConfigs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BrokerConfig{}
	for rows.Next() {
		var i BrokerConfig
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Config,
			&i.Active,
			&i.HealthStatus,
			&i.LastHealthCheck,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DlqEnabled,
			&i.DlqBrokerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDLQMessages = `-- name: ListDLQMessages :many
SELECT id, message_id, route_id, trigger_id, pipeline_id, source_broker_id, dlq_broker_id, broker_name, queue, exchange, routing_key, headers, body, error_message, failure_count, first_failure, last_failure, next_retry, status, metadata, created_at, updated_at FROM dlq_messages
ORDER BY last_failure DESC
LIMIT $1 OFFSET $2
`

type ListDLQMessagesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListDLQMessages(ctx context.Context, arg ListDLQMessagesParams) ([]DlqMessage, error) {
	rows, err := q.db.Query(ctx, listDLQMessages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DlqMessage{}
	for rows.Next() {
		var i DlqMessage
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.RouteID,
			&i.TriggerID,
			&i.PipelineID,
			&i.SourceBrokerID,
			&i.DlqBrokerID,
			&i.BrokerName,
			&i.Queue,
			&i.Exchange,
			&i.RoutingKey,
			&i.Headers,
			&i.Body,
			&i.ErrorMessage,
			&i.FailureCount,
			&i.FirstFailure,
			&i.LastFailure,
			&i.NextRetry,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDLQMessagesByDLQBroker = `-- name: ListDLQMessagesByDLQBroker :many
SELECT id, message_id, route_id, trigger_id, pipeline_id, source_broker_id, dlq_broker_id, broker_name, queue, exchange, routing_key, headers, body, error_message, failure_count, first_failure, last_failure, next_retry, status, metadata, created_at, updated_at FROM dlq_messages
WHERE dlq_broker_id = $1
ORDER BY last_failure DESC
LIMIT $2 OFFSET $3
`

type ListDLQMessagesByDLQBrokerParams struct {
	DlqBrokerID int32 `json:"dlq_broker_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

func (q *Queries) ListDLQMessagesByDLQBroker(ctx context.Context, arg ListDLQMessagesByDLQBrokerParams) ([]DlqMessage, error) {
	rows, err := q.db.Query(ctx, listDLQMessagesByDLQBroker, arg.DlqBrokerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DlqMessage{}
	for rows.Next() {
		var i DlqMessage
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.RouteID,
			&i.TriggerID,
			&i.PipelineID,
			&i.SourceBrokerID,
			&i.DlqBrokerID,
			&i.BrokerName,
			&i.Queue,
			&i.Exchange,
			&i.RoutingKey,
			&i.Headers,
			&i.Body,
			&i.ErrorMessage,
			&i.FailureCount,
			&i.FirstFailure,
			&i.LastFailure,
			&i.NextRetry,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDLQMessagesByRoute = `-- name: ListDLQMessagesByRoute :many
SELECT id, message_id, route_id, trigger_id, pipeline_id, source_broker_id, dlq_broker_id, broker_name, queue, exchange, routing_key, headers, body, error_message, failure_count, first_failure, last_failure, next_retry, status, metadata, created_at, updated_at FROM dlq_messages
WHERE route_id = $1
ORDER BY last_failure DESC
LIMIT $2 OFFSET $3
`

type ListDLQMessagesByRouteParams struct {
	RouteID int32 `json:"route_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListDLQMessagesByRoute(ctx context.Context, arg ListDLQMessagesByRouteParams) ([]DlqMessage, error) {
	rows, err := q.db.Query(ctx, listDLQMessagesByRoute, arg.RouteID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DlqMessage{}
	for rows.Next() {
		var i DlqMessage
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.RouteID,
			&i.TriggerID,
			&i.PipelineID,
			&i.SourceBrokerID,
			&i.DlqBrokerID,
			&i.BrokerName,
			&i.Queue,
			&i.Exchange,
			&i.RoutingKey,
			&i.Headers,
			&i.Body,
			&i.ErrorMessage,
			&i.FailureCount,
			&i.FirstFailure,
			&i.LastFailure,
			&i.NextRetry,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDLQMessagesBySourceBroker = `-- name: ListDLQMessagesBySourceBroker :many
SELECT id, message_id, route_id, trigger_id, pipeline_id, source_broker_id, dlq_broker_id, broker_name, queue, exchange, routing_key, headers, body, error_message, failure_count, first_failure, last_failure, next_retry, status, metadata, created_at, updated_at FROM dlq_messages
WHERE source_broker_id = $1
ORDER BY last_failure DESC
LIMIT $2 OFFSET $3
`

type ListDLQMessagesBySourceBrokerParams struct {
	SourceBrokerID int32 `json:"source_broker_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

func (q *Queries) ListDLQMessagesBySourceBroker(ctx context.Context, arg ListDLQMessagesBySourceBrokerParams) ([]DlqMessage, error) {
	rows, err := q.db.Query(ctx, listDLQMessagesBySourceBroker, arg.SourceBrokerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DlqMessage{}
	for rows.Next() {
		var i DlqMessage
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.RouteID,
			&i.TriggerID,
			&i.PipelineID,
			&i.SourceBrokerID,
			&i.DlqBrokerID,
			&i.BrokerName,
			&i.Queue,
			&i.Exchange,
			&i.RoutingKey,
			&i.Headers,
			&i.Body,
			&i.ErrorMessage,
			&i.FailureCount,
			&i.FirstFailure,
			&i.LastFailure,
			&i.NextRetry,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDLQMessagesByStatus = `-- name: ListDLQMessagesByStatus :many
SELECT id, message_id, route_id, trigger_id, pipeline_id, source_broker_id, dlq_broker_id, broker_name, queue, exchange, routing_key, headers, body, error_message, failure_count, first_failure, last_failure, next_retry, status, metadata, created_at, updated_at FROM dlq_messages
WHERE status = $1
ORDER BY last_failure DESC
LIMIT $2 OFFSET $3
`

type ListDLQMessagesByStatusParams struct {
	Status *string `json:"status"`
	Limit  int32   `json:"limit"`
	Offset int32   `json:"offset"`
}

func (q *Queries) ListDLQMessagesByStatus(ctx context.Context, arg ListDLQMessagesByStatusParams) ([]DlqMessage, error) {
	rows, err := q.db.Query(ctx, listDLQMessagesByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DlqMessage{}
	for rows.Next() {
		var i DlqMessage
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.RouteID,
			&i.TriggerID,
			&i.PipelineID,
			&i.SourceBrokerID,
			&i.DlqBrokerID,
			&i.BrokerName,
			&i.Queue,
			&i.Exchange,
			&i.RoutingKey,
			&i.Headers,
			&i.Body,
			&i.ErrorMessage,
			&i.FailureCount,
			&i.FirstFailure,
			&i.LastFailure,
			&i.NextRetry,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingDLQMessages = `-- name: ListPendingDLQMessages :many
SELECT id, message_id, route_id, trigger_id, pipeline_id, source_broker_id, dlq_broker_id, broker_name, queue, exchange, routing_key, headers, body, error_message, failure_count, first_failure, last_failure, next_retry, status, metadata, created_at, updated_at FROM dlq_messages 
WHERE status = 'pending' AND next_retry <= CURRENT_TIMESTAMP
ORDER BY next_retry ASC
LIMIT $1
`

func (q *Queries) ListPendingDLQMessages(ctx context.Context, limit int32) ([]DlqMessage, error) {
	rows, err := q.db.Query(ctx, listPendingDLQMessages, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DlqMessage{}
	for rows.Next() {
		var i DlqMessage
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.RouteID,
			&i.TriggerID,
			&i.PipelineID,
			&i.SourceBrokerID,
			&i.DlqBrokerID,
			&i.BrokerName,
			&i.Queue,
			&i.Exchange,
			&i.RoutingKey,
			&i.Headers,
			&i.Body,
			&i.ErrorMessage,
			&i.FailureCount,
			&i.FirstFailure,
			&i.LastFailure,
			&i.NextRetry,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPipelines = `-- name: ListPipelines :many
SELECT id, name, description, stages, active, created_at, updated_at FROM pipelines ORDER BY created_at DESC
`

func (q *Queries) ListPipelines(ctx context.Context) ([]Pipeline, error) {
	rows, err := q.db.Query(ctx, listPipelines)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Pipeline{}
	for rows.Next() {
		var i Pipeline
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Stages,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoutes = `-- name: ListRoutes :many
SELECT id, name, endpoint, method, queue, exchange, routing_key, filters, headers, active, created_at, updated_at, pipeline_id, trigger_id, destination_broker_id, priority, condition_expression FROM routes ORDER BY priority ASC, created_at DESC
`

func (q *Queries) ListRoutes(ctx context.Context) ([]Route, error) {
	rows, err := q.db.Query(ctx, listRoutes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Route{}
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Endpoint,
			&i.Method,
			&i.Queue,
			&i.Exchange,
			&i.RoutingKey,
			&i.Filters,
			&i.Headers,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PipelineID,
			&i.TriggerID,
			&i.DestinationBrokerID,
			&i.Priority,
			&i.ConditionExpression,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSettings = `-- name: ListSettings :many
SELECT key, value, updated_at FROM settings ORDER BY key
`

func (q *Queries) ListSettings(ctx context.Context) ([]Setting, error) {
	rows, err := q.db.Query(ctx, listSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Setting{}
	for rows.Next() {
		var i Setting
		if err := rows.Scan(&i.Key, &i.Value, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTriggers = `-- name: ListTriggers :many
SELECT id, name, type, config, status, active, error_message, last_execution, next_execution, created_at, updated_at FROM triggers ORDER BY created_at DESC
`

func (q *Queries) ListTriggers(ctx context.Context) ([]Trigger, error) {
	rows, err := q.db.Query(ctx, listTriggers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Trigger{}
	for rows.Next() {
		var i Trigger
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Config,
			&i.Status,
			&i.Active,
			&i.ErrorMessage,
			&i.LastExecution,
			&i.NextExecution,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, password_hash, is_default, created_at, updated_at FROM users ORDER BY created_at DESC
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.PasswordHash,
			&i.IsDefault,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhookLogs = `-- name: ListWebhookLogs :many
SELECT id, route_id, method, endpoint, headers, body, status_code, error, processed_at, trigger_id, pipeline_id, transformation_time_ms, broker_publish_time_ms FROM webhook_logs ORDER BY processed_at DESC LIMIT $1 OFFSET $2
`

type ListWebhookLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListWebhookLogs(ctx context.Context, arg ListWebhookLogsParams) ([]WebhookLog, error) {
	rows, err := q.db.Query(ctx, listWebhookLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookLog{}
	for rows.Next() {
		var i WebhookLog
		if err := rows.Scan(
			&i.ID,
			&i.RouteID,
			&i.Method,
			&i.Endpoint,
			&i.Headers,
			&i.Body,
			&i.StatusCode,
			&i.Error,
			&i.ProcessedAt,
			&i.TriggerID,
			&i.PipelineID,
			&i.TransformationTimeMs,
			&i.BrokerPublishTimeMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setSetting = `-- name: SetSetting :exec
INSERT INTO settings (key, value, updated_at)
VALUES ($1, $2, CURRENT_TIMESTAMP)
ON CONFLICT (key) DO UPDATE 
SET value = EXCLUDED.value, updated_at = CURRENT_TIMESTAMP
`

type SetSettingParams struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// Settings queries
func (q *Queries) SetSetting(ctx context.Context, arg SetSettingParams) error {
	_, err := q.db.Exec(ctx, setSetting, arg.Key, arg.Value)
	return err
}

const updateBrokerConfig = `-- name: UpdateBrokerConfig :one
UPDATE broker_configs
SET name = $2, type = $3, config = $4, active = $5, dlq_enabled = $6, dlq_broker_id = $7,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, type, config, active, health_status, last_health_check, created_at, updated_at, dlq_enabled, dlq_broker_id
`

type UpdateBrokerConfigParams struct {
	ID          int32  `json:"id"`
	Name        string `json:"name"`
	Type        string `json:"type"`
	Config      []byte `json:"config"`
	Active      *bool  `json:"active"`
	DlqEnabled  *bool  `json:"dlq_enabled"`
	DlqBrokerID *int32 `json:"dlq_broker_id"`
}

func (q *Queries) UpdateBrokerConfig(ctx context.Context, arg UpdateBrokerConfigParams) (BrokerConfig, error) {
	row := q.db.QueryRow(ctx, updateBrokerConfig,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.Config,
		arg.Active,
		arg.DlqEnabled,
		arg.DlqBrokerID,
	)
	var i BrokerConfig
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.Active,
		&i.HealthStatus,
		&i.LastHealthCheck,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DlqEnabled,
		&i.DlqBrokerID,
	)
	return i, err
}

const updateDLQMessage = `-- name: UpdateDLQMessage :one
UPDATE dlq_messages
SET failure_count = $2, last_failure = $3, next_retry = $4, 
    error_message = $5, status = $6, metadata = $7, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, message_id, route_id, trigger_id, pipeline_id, source_broker_id, dlq_broker_id, broker_name, queue, exchange, routing_key, headers, body, error_message, failure_count, first_failure, last_failure, next_retry, status, metadata, created_at, updated_at
`

type UpdateDLQMessageParams struct {
	ID           int32            `json:"id"`
	FailureCount *int32           `json:"failure_count"`
	LastFailure  pgtype.Timestamp `json:"last_failure"`
	NextRetry    pgtype.Timestamp `json:"next_retry"`
	ErrorMessage string           `json:"error_message"`
	Status       *string          `json:"status"`
	Metadata     []byte           `json:"metadata"`
}

func (q *Queries) UpdateDLQMessage(ctx context.Context, arg UpdateDLQMessageParams) (DlqMessage, error) {
	row := q.db.QueryRow(ctx, updateDLQMessage,
		arg.ID,
		arg.FailureCount,
		arg.LastFailure,
		arg.NextRetry,
		arg.ErrorMessage,
		arg.Status,
		arg.Metadata,
	)
	var i DlqMessage
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.RouteID,
		&i.TriggerID,
		&i.PipelineID,
		&i.SourceBrokerID,
		&i.DlqBrokerID,
		&i.BrokerName,
		&i.Queue,
		&i.Exchange,
		&i.RoutingKey,
		&i.Headers,
		&i.Body,
		&i.ErrorMessage,
		&i.FailureCount,
		&i.FirstFailure,
		&i.LastFailure,
		&i.NextRetry,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDLQMessageStatus = `-- name: UpdateDLQMessageStatus :exec
UPDATE dlq_messages
SET status = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateDLQMessageStatusParams struct {
	ID     int32   `json:"id"`
	Status *string `json:"status"`
}

func (q *Queries) UpdateDLQMessageStatus(ctx context.Context, arg UpdateDLQMessageStatusParams) error {
	_, err := q.db.Exec(ctx, updateDLQMessageStatus, arg.ID, arg.Status)
	return err
}

const updatePipeline = `-- name: UpdatePipeline :one
UPDATE pipelines
SET name = $2, description = $3, stages = $4, active = $5,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, description, stages, active, created_at, updated_at
`

type UpdatePipelineParams struct {
	ID          int32   `json:"id"`
	Name        string  `json:"name"`
	Description *string `json:"description"`
	Stages      []byte  `json:"stages"`
	Active      *bool   `json:"active"`
}

func (q *Queries) UpdatePipeline(ctx context.Context, arg UpdatePipelineParams) (Pipeline, error) {
	row := q.db.QueryRow(ctx, updatePipeline,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Stages,
		arg.Active,
	)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Stages,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRoute = `-- name: UpdateRoute :one
UPDATE routes
SET name = $2, endpoint = $3, method = $4, queue = $5, exchange = $6,
    routing_key = $7, filters = $8, headers = $9, active = $10,
    pipeline_id = $11, trigger_id = $12, destination_broker_id = $13,
    priority = $14, condition_expression = $15, signature_config = $16,
    signature_secret = $17, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, endpoint, method, queue, exchange, routing_key, filters, headers, active, created_at, updated_at, pipeline_id, trigger_id, destination_broker_id, priority, condition_expression, signature_config, signature_secret
`

type UpdateRouteParams struct {
	ID                  int32   `json:"id"`
	Name                string  `json:"name"`
	Endpoint            string  `json:"endpoint"`
	Method              string  `json:"method"`
	Queue               string  `json:"queue"`
	Exchange            *string `json:"exchange"`
	RoutingKey          string  `json:"routing_key"`
	Filters             []byte  `json:"filters"`
	Headers             []byte  `json:"headers"`
	Active              *bool   `json:"active"`
	PipelineID          *int32  `json:"pipeline_id"`
	TriggerID           *int32  `json:"trigger_id"`
	DestinationBrokerID *int32  `json:"destination_broker_id"`
	Priority            *int32  `json:"priority"`
	ConditionExpression *string `json:"condition_expression"`
	SignatureConfig     []byte  `json:"signature_config"`
	SignatureSecret     *string `json:"signature_secret"`
}

func (q *Queries) UpdateRoute(ctx context.Context, arg UpdateRouteParams) (Route, error) {
	row := q.db.QueryRow(ctx, updateRoute,
		arg.ID,
		arg.Name,
		arg.Endpoint,
		arg.Method,
		arg.Queue,
		arg.Exchange,
		arg.RoutingKey,
		arg.Filters,
		arg.Headers,
		arg.Active,
		arg.PipelineID,
		arg.TriggerID,
		arg.DestinationBrokerID,
		arg.Priority,
		arg.ConditionExpression,
		arg.SignatureConfig,
		arg.SignatureSecret,
	)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Endpoint,
		&i.Method,
		&i.Queue,
		&i.Exchange,
		&i.RoutingKey,
		&i.Filters,
		&i.Headers,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PipelineID,
		&i.TriggerID,
		&i.DestinationBrokerID,
		&i.Priority,
		&i.ConditionExpression,
		&i.SignatureConfig,
		&i.SignatureSecret,
	)
	return i, err
}

const updateTrigger = `-- name: UpdateTrigger :one
UPDATE triggers
SET name = $2, type = $3, config = $4, status = $5, active = $6,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, type, config, status, active, error_message, last_execution, next_execution, created_at, updated_at
`

type UpdateTriggerParams struct {
	ID     int32   `json:"id"`
	Name   string  `json:"name"`
	Type   string  `json:"type"`
	Config []byte  `json:"config"`
	Status *string `json:"status"`
	Active *bool   `json:"active"`
}

func (q *Queries) UpdateTrigger(ctx context.Context, arg UpdateTriggerParams) (Trigger, error) {
	row := q.db.QueryRow(ctx, updateTrigger,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.Config,
		arg.Status,
		arg.Active,
	)
	var i Trigger
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.Status,
		&i.Active,
		&i.ErrorMessage,
		&i.LastExecution,
		&i.NextExecution,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users 
SET username = $2, password_hash = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, username, password_hash, is_default, created_at, updated_at
`

type UpdateUserParams struct {
	ID           int32  `json:"id"`
	Username     string `json:"username"`
	PasswordHash string `json:"password_hash"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser, arg.ID, arg.Username, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserCredentials = `-- name: UpdateUserCredentials :exec
UPDATE users
SET username = $2, password_hash = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateUserCredentialsParams struct {
	ID           int32  `json:"id"`
	Username     string `json:"username"`
	PasswordHash string `json:"password_hash"`
}

func (q *Queries) UpdateUserCredentials(ctx context.Context, arg UpdateUserCredentialsParams) error {
	_, err := q.db.Exec(ctx, updateUserCredentials, arg.ID, arg.Username, arg.PasswordHash)
	return err
}
