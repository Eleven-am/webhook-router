package triggers

import (
	"context"
	"time"
	"webhook-router/internal/brokers"
)

// TriggerEvent represents an event generated by a trigger
type TriggerEvent struct {
	ID          string                 `json:"id"`
	TriggerID   int                    `json:"trigger_id"`
	TriggerName string                 `json:"trigger_name"`
	Type        string                 `json:"type"`
	Timestamp   time.Time              `json:"timestamp"`
	Data        map[string]interface{} `json:"data"`
	Headers     map[string]string      `json:"headers"`
	Source      TriggerSource          `json:"source"`
}

// TriggerSource provides information about the trigger source
type TriggerSource struct {
	Type     string `json:"type"`
	Name     string `json:"name"`
	URL      string `json:"url,omitempty"`
	Endpoint string `json:"endpoint,omitempty"`
}

// TriggerHandler processes trigger events
type TriggerHandler func(event *TriggerEvent) error

// Trigger interface defines the contract for all trigger types
type Trigger interface {
	// Name returns the trigger name
	Name() string
	
	// Type returns the trigger type
	Type() string
	
	// ID returns the trigger ID
	ID() int
	
	// Start begins trigger execution
	Start(ctx context.Context, handler TriggerHandler) error
	
	// Stop stops the trigger
	Stop() error
	
	// IsRunning returns true if the trigger is currently running
	IsRunning() bool
	
	// Config returns the trigger configuration
	Config() TriggerConfig
	
	// Health returns the trigger health status
	Health() error
	
	// LastExecution returns the last execution time
	LastExecution() *time.Time
	
	// NextExecution returns the next scheduled execution time (for scheduled triggers)
	NextExecution() *time.Time
}

// TriggerConfig interface for trigger configurations
type TriggerConfig interface {
	GetType() string
	Validate() error
	GetID() int
	GetName() string
}

// TriggerFactory creates triggers
type TriggerFactory interface {
	Create(config TriggerConfig) (Trigger, error)
	GetType() string
}

// BaseTriggerConfig provides common fields for all trigger configs
type BaseTriggerConfig struct {
	ID          int                    `json:"id"`
	Name        string                 `json:"name"`
	Type        string                 `json:"type"`
	Active      bool                   `json:"active"`
	Settings    map[string]interface{} `json:"settings"`
	CreatedAt   time.Time              `json:"created_at"`
	UpdatedAt   time.Time              `json:"updated_at"`
}

func (c *BaseTriggerConfig) GetID() int {
	return c.ID
}

func (c *BaseTriggerConfig) GetName() string {
	return c.Name
}

func (c *BaseTriggerConfig) GetType() string {
	return c.Type
}

// TriggerRegistry manages trigger factories
type TriggerRegistry struct {
	factories map[string]TriggerFactory
}

func NewTriggerRegistry() *TriggerRegistry {
	return &TriggerRegistry{
		factories: make(map[string]TriggerFactory),
	}
}

func (r *TriggerRegistry) Register(triggerType string, factory TriggerFactory) {
	r.factories[triggerType] = factory
}

func (r *TriggerRegistry) Create(triggerType string, config TriggerConfig) (Trigger, error) {
	factory, exists := r.factories[triggerType]
	if !exists {
		return nil, ErrTriggerTypeNotRegistered
	}
	return factory.Create(config)
}

func (r *TriggerRegistry) GetAvailableTypes() []string {
	types := make([]string, 0, len(r.factories))
	for triggerType := range r.factories {
		types = append(types, triggerType)
	}
	return types
}

// TriggerManager manages all triggers in the system
type TriggerManager struct {
	registry *TriggerRegistry
	triggers map[int]Trigger
	ctx      context.Context
	cancel   context.CancelFunc
	broker   brokers.Broker // For publishing trigger events
}

func NewTriggerManager(broker brokers.Broker) *TriggerManager {
	ctx, cancel := context.WithCancel(context.Background())
	return &TriggerManager{
		registry: NewTriggerRegistry(),
		triggers: make(map[int]Trigger),
		ctx:      ctx,
		cancel:   cancel,
		broker:   broker,
	}
}

func (m *TriggerManager) RegisterFactory(triggerType string, factory TriggerFactory) {
	m.registry.Register(triggerType, factory)
}

func (m *TriggerManager) AddTrigger(config TriggerConfig) error {
	trigger, err := m.registry.Create(config.GetType(), config)
	if err != nil {
		return err
	}
	
	m.triggers[config.GetID()] = trigger
	
	// Start the trigger if it's active
	if baseCfg, ok := config.(*BaseTriggerConfig); ok && baseCfg.Active {
		return m.StartTrigger(config.GetID())
	}
	
	return nil
}

func (m *TriggerManager) RemoveTrigger(id int) error {
	if trigger, exists := m.triggers[id]; exists {
		if trigger.IsRunning() {
			trigger.Stop()
		}
		delete(m.triggers, id)
	}
	return nil
}

func (m *TriggerManager) StartTrigger(id int) error {
	trigger, exists := m.triggers[id]
	if !exists {
		return ErrTriggerNotFound
	}
	
	handler := m.createTriggerHandler(trigger)
	return trigger.Start(m.ctx, handler)
}

func (m *TriggerManager) StopTrigger(id int) error {
	trigger, exists := m.triggers[id]
	if !exists {
		return ErrTriggerNotFound
	}
	
	return trigger.Stop()
}

func (m *TriggerManager) GetTrigger(id int) (Trigger, error) {
	trigger, exists := m.triggers[id]
	if !exists {
		return nil, ErrTriggerNotFound
	}
	return trigger, nil
}

func (m *TriggerManager) GetAllTriggers() map[int]Trigger {
	return m.triggers
}

func (m *TriggerManager) Stop() {
	// Stop all triggers
	for _, trigger := range m.triggers {
		if trigger.IsRunning() {
			trigger.Stop()
		}
	}
	
	// Cancel context
	m.cancel()
}

// createTriggerHandler creates a handler function for trigger events
func (m *TriggerManager) createTriggerHandler(trigger Trigger) TriggerHandler {
	return func(event *TriggerEvent) error {
		// Convert trigger event to broker message
		message := &brokers.Message{
			Queue:      "trigger-events",
			Exchange:   "",
			RoutingKey: event.Type,
			Headers: map[string]string{
				"trigger_id":   string(rune(event.TriggerID)),
				"trigger_name": event.TriggerName,
				"trigger_type": event.Type,
				"event_id":     event.ID,
			},
			Body:      []byte(event.Data["body"].(string)), // This will need proper JSON marshaling
			Timestamp: event.Timestamp,
			MessageID: event.ID,
		}
		
		// Add custom headers from the event
		for key, value := range event.Headers {
			message.Headers["event_"+key] = value
		}
		
		// Publish to broker if available
		if m.broker != nil {
			return m.broker.Publish(message)
		}
		
		return nil
	}
}